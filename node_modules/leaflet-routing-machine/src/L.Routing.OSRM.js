(function() {
	'use strict';

	var L = require('leaflet'),
		corslite = require('corslite'),
		polyline = require('polyline');

	// Ignore camelcase naming for this file, since OSRM's API uses
	// underscores.
	/* jshint camelcase: false */

	L.Routing = L.Routing || {};
	L.extend(L.Routing, require('./L.Routing.Waypoint'));

	L.Routing.OSRM = L.Class.extend({
		options: {
			serviceUrl: '//router.project-osrm.org/viaroute',
			timeout: 30 * 1000,
			routingOptions: {}
		},

		initialize: function(options) {
			L.Util.setOptions(this, options);
			this._hints = {
				locations: {}
			};
		},

		route: function(waypoints, callback, context, options) {
			var timedOut = false,
				wps = [],
				url,
				timer,
				wp,
				i;

			url = this.buildRouteUrl(waypoints, L.extend({}, this.options.routingOptions, options));

			timer = setTimeout(function() {
				timedOut = true;
				callback.call(context || callback, {
					status: -1,
					message: 'OSRM request timed out.'
				});
			}, this.options.timeout);

			// Create a copy of the waypoints, since they
			// might otherwise be asynchronously modified while
			// the request is being processed.
			for (i = 0; i < waypoints.length; i++) {
				wp = waypoints[i];
				wps.push(new L.Routing.Waypoint(wp.latLng, wp.name, wp.options));
			}

			corslite(url, L.bind(function(err, resp) {
				var data,
					errorMessage,
					statusCode;

				clearTimeout(timer);
				if (!timedOut) {
					errorMessage = 'HTTP request failed: ' + err;
					statusCode = -1;

					if (!err) {
						try {
							data = JSON.parse(resp.responseText);
							try {
								return this._routeDone(data, wps, callback, context);
							} catch (ex) {
								statusCode = -3;
								errorMessage = ex.toString();
							}
						} catch (ex) {
							statusCode = -2;
							errorMessage = 'Error parsing OSRM response: ' + ex.toString();
						}
					}

					callback.call(context || callback, {
						status: statusCode,
						message: errorMessage
					});
				}
			}, this));

			return this;
		},

        _handleRoute: function(response, route_index, inputWaypoints) {
			var coordinates,
			    actualWaypoints,
			    i,
                si,
                gi,
                num_steps,
                geom,
                via_indices = [],
                instructions = [],
                step,
                total_steps,
                passed;

            coordinates = new Array();

            via_indices.push(coordinates.length);
            total_steps = 0;
            for( i = 0; i < response.routes[route_index].legs.length; i++ ){
              total_steps += response.routes[route_index].legs[i].steps.length;
            }
            for( i = 0; i < response.routes[route_index].legs.length; i++ ){
              num_steps = response.routes[route_index].legs[i].steps.length;
              for( si = 0; si < num_steps; si++ ){
                passed = 0;
                step = response.routes[route_index].legs[i].steps[si];
                if( !this._keepInstruction(step.maneuver) ){
                    passed++;
                    response.routes[route_index].legs[i].steps[si+1].duration += step.duration;
                    response.routes[route_index].legs[i].steps[si+1].distance += step.distance;
                } else {
                    instructions.push( this._handleInstruction(step, coordinates.length-1, si, total_steps, passed) );
                    passed = 0;
                }
                if( step.geometry !== "" ){
                  geom = this._decodePolyline(response.routes[route_index].legs[i].steps[si].geometry);
                  for( gi = 0; gi < geom.length; gi++){
                      coordinates.push(geom[gi]);
                  }
                }

              }
              via_indices.push(coordinates.length-1);
            }
            instructions[0].instruction = "depart";
            instructions[instructions.length-1].instruction = "arrive";

			actualWaypoints = this._decodeWaypoints(response.waypoints,inputWaypoints);//this._toWaypoints(inputWaypoints, response.via_points);
			return {
				name: response.routes[route_index].legs[0].summary,
				coordinates: coordinates,
				instructions: instructions,
				summary: this._convertSummary(response.routes[route_index]),
				inputWaypoints: inputWaypoints,
				waypoints: actualWaypoints,
				waypointIndices: via_indices//this._clampIndices(response.via_indices, coordinates)
			};
        },

		_routeDone: function(response, inputWaypoints, callback, context) {
			var alts = [],
			    i;

			context = context || callback;
			if (response.code !== "ok"){
				callback.call(context, {
					status: response.status,
					message: response.status_message
				});
				return;
			}

            for( i = 0; i < response.routes.length; i++ ){
              alts.push( this._handleRoute( response, i, inputWaypoints ) );
            }

			// only versions <4.5.0 will support this flag
			if (response.hint_data) {
				this._saveHintData(response.hint_data, inputWaypoints);
			}
			callback.call(context, null, alts);
		},

		_decodePolyline: function(routeGeometry) {
			var cs = polyline.decode(routeGeometry, 5),
				result = new Array(cs.length),
				i, tmp;
			for (i = cs.length - 1; i >= 0; i--) {
				result[i] = L.latLng(cs[i]);
			}
			return result;
		},

		_toWaypoints: function(inputWaypoints, vias) {
			var wps = [],
			    i;
			for (i = 0; i < vias.length; i++) {
				wps.push(L.Routing.waypoint(L.latLng(vias[i]),
				                            inputWaypoints[i].name,
				                            inputWaypoints[i].options));
			}

			return wps;
		},

        _decodeWaypoints: function(wp_objects,input_waypoints) {
            var result = [],
                i;
            for( i = 0; i < wp_objects.length; i++ ){
              result.push(L.Routing.waypoint(L.latLng(wp_objects[i].location), wp_objects[i].way_name, input_waypoints[i].options ) );
            }
            return result;
        },

		buildRouteUrl: function(waypoints, options) {
			var locs = [],
				wp,
			    computeInstructions,
			    computeAlternative,
			    locationKey,
			    hint;

			for (var i = 0; i < waypoints.length; i++) {
				wp = waypoints[i];
				locationKey = this._locationKey(wp.latLng);
				locs.push(locationKey);

				hint = this._hints.locations[locationKey];
				if (hint) {
					locs.push('hint=' + hint);
				}

				if (wp.options && wp.options.allowUTurn) {
					locs.push('u=true');
				}
			}

			computeAlternative = computeInstructions =
				!(options && options.geometryOnly);

			return this.options.serviceUrl + '/' +
				locs.join(';') + "?overview=false";
		},

		_locationKey: function(location) {
			return location.lng + ',' + location.lat;
		},

		_saveHintData: function(hintData, waypoints) {
			var loc;
			this._hints = {
				checksum: hintData.checksum,
				locations: {}
			};
			for (var i = hintData.locations.length - 1; i >= 0; i--) {
				loc = waypoints[i].latLng;
				this._hints.locations[this._locationKey(loc)] = hintData.locations[i];
			}
		},

		_convertSummary: function(osrmSummary) {
			return {
				totalDistance: osrmSummary.distance,
				totalTime: Math.round(osrmSummary.duration)
			};
		},

        _legacyTranslateInstruction: function( instruction, index, all, passed_intersections ){
          if( instruction.type === "end of road" )
            instruction.type = "turn";

          if( instruction.type === "waypoint" ){
            if( index === 0 )
              return "Straight";    //start is handled separately
            if( index+1 < all )
              return "WaypointReached";
            return "DestinationReached";
          }

          if( instruction.type === "roundabout" ){
            return "Roundabout";
          }

          if( instruction.type === "turn" || instruction.type === "continue" ) {
                switch (instruction.modifier) {
                  case 'straight':
                    return 'Continue';
                  case 'uturn':
                    return 'TurnAround';
                  case 'sharp right':
                    return 'SharpRight';
                  case 'right':
                    return 'Right'
                  case 'slight right':
                    return 'SlightRight';
                  case 'sharp left':
                    return 'SharpLeft';
                  case 'left':
                    return 'Left';
                  case 'slight left':
                    return 'SlightLeft';
                }
          }
          return 'Straight';    //Fallback
        },

        _keepInstruction: function( instruction ){
          if( instruction.type === "passing intersection" )
            return false;
          if( instruction.type === "stay on roundabout" )
            return false;
          return true;
        },

        _directionFromHeading: function(heading){
            if (heading <= 22.5)
            {
                return "N";
            }
            if (heading <= 67.5)
            {
                return "NE";
            }
            if (heading <= 112.5)
            {
                return "E";
            }
            if (heading <= 157.5)
            {
                return "SE";
            }
            if (heading <= 202.5)
            {
                return "S";
            }
            if (heading <= 247.5)
            {
                return "SW";
            }
            if (heading <= 292.5)
            {
                return "W";
            }
            if (heading <= 337.5)
            {
                return "NW";
            }
            return "N";
        },

        _handleInstruction: function(step, running_index, step_index, of_steps, passed_intersections) {
            return {
                type: this._legacyTranslateInstruction(step.maneuver, step_index, of_steps, passed_intersections),
                instruction: step.maneuver.type !== 'roundabout' ? step.maneuver.type : ('exit' in step.maneuver && step.maneuver.exit !== 0 ? 'roundabout' : 'enter-roundabout'),
                modifier:step.maneuver.modifier,
                distance: step.distance,
                time : step.duration,
                road : step.name,
                direction: this._directionFromHeading(step.maneuver.bearing_after),
                exit: ('exit' in step.maneuver && step.maneuver.exit !== 0) ? step.maneuver.exit : undefined,
                index : running_index
            };
        },
	});

	L.Routing.osrm = function(options) {
		return new L.Routing.OSRM(options);
	};

	module.exports = L.Routing;
})();
